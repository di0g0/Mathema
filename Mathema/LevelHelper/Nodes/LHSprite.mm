//  This file was generated by LevelHelper
//  http://www.levelhelper.org
//
//  LevelHelperLoader.mm
//  Created by Bogdan Vladu
//  Copyright 2011 Bogdan Vladu. All rights reserved.
////////////////////////////////////////////////////////////////////////////////
//
//  This software is provided 'as-is', without any express or implied
//  warranty.  In no event will the authors be held liable for any damages
//  arising from the use of this software.
//  Permission is granted to anyone to use this software for any purpose,
//  including commercial applications, and to alter it and redistribute it
//  freely, subject to the following restrictions:
//  The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software
//  in a product, an acknowledgment in the product documentation would be
//  appreciated but is not required.
//  Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
//  This notice may not be removed or altered from any source distribution.
//  By "software" the author refers to this code file and not the application 
//  that was used to generate this file.
//
////////////////////////////////////////////////////////////////////////////////
#import "LHSprite.h"

#import "SHDocumentLoader.h"

#import "LHSettings.h"
#import "LHPathNode.h"
#import "LHParallaxNode.h"
#import "LHAnimationNode.h"
#import "LevelHelperLoader.h"
#import "LHTouchMgr.h"
#import "LHCuttingEngineMgr.h"
#import "LHJoint.h"

#import "LHFixture.h"

#import "LHDictionaryExt.h"

#import "LHCustomClasses.h"


static int untitledSpritesCount = 0;
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
@interface LHJoint (LH_JOINT_SPRITE_EXT) 
@end
@implementation LHJoint (LH_JOINT_SPRITE_EXT)
@end

@interface LHBezier (LH_BEZIER_SPRITE_EXT) 
-(NSArray*)pathPoints;
@end
@implementation LHBezier (LH_BEZIER_SPRITE_EXT)
-(NSArray*)pathPoints{
    return pathPoints;
}
@end


@interface LHSprite (Private)

@end
////////////////////////////////////////////////////////////////////////////////
@implementation LHSprite
@synthesize usesOverloadedTransformations;
@synthesize realScale;
@synthesize swallowTouches;
@synthesize shSceneName;
@synthesize shSheetName;
@synthesize shSpriteName;
////////////////////////////////////////////////////////////////////////////////
//-(oneway void)release{
//    NSLog(@"LHSPrite release %@ %d", uniqueName, [self retainCount]);
//    [super release];
//}
-(void) dealloc{		
    NSLog(@"LH Sprite Dealloc %@", uniqueName);
    
    [self removeBodyFromWorld];
    
    [LevelHelperLoader removeTouchDispatcherFromObject:self];
    
    touchBeginObserver = nil;
    touchMovedObserver = nil;
    touchEndedObserver = nil;
    
    if(NULL != parallaxFollowingThisSprite)
        [parallaxFollowingThisSprite followSprite:NULL 
                                changePositionOnX:false 
                                changePositionOnY:false];

    if(NULL != spriteIsInParallax){
        [spriteIsInParallax removeChild:self];
        spriteIsInParallax = nil;
    }
                
#ifndef LH_ARC_ENABLED    
    if(animation)
        [animation release];

    if(pathNode)
        [pathNode release];
    
    if(pathDefaultName)
        [pathDefaultName release];
    
    if(userCustomInfo)
        [userCustomInfo release];

    if(shSceneName)
        [shSceneName release];
    
    [shSheetName release];
    [shSpriteName release];
    
    if(fixturesObj)
        [fixturesObj release];
    
    if(touchBeginObserver)
        [touchBeginObserver release];
    if(touchMovedObserver)
        [touchMovedObserver release];
    if(touchEndedObserver)
        [touchEndedObserver release];
    
    if(imageFile)
        [imageFile release];
        
    [uniqueName release];
    
	[super dealloc];
#endif
}
////////////////////////////////////////////////////////////////////////////////
-(void) loadUserCustomInfoFromDictionary:(NSDictionary*)dictionary{
    userCustomInfo = nil;
    if(!dictionary)return;
    
    NSString* className = [dictionary stringForKey:@"ClassName"];
    Class customClass = NSClassFromString(className);

    if(!customClass) return;
    
    userCustomInfo = [customClass performSelector:@selector(customClassInstance)];
#ifndef LH_ARC_ENABLED
    [userCustomInfo retain];
#endif
    [userCustomInfo setPropertiesFromDictionary:[dictionary objectForKey:@"ClassRepresentation"]];
}
//------------------------------------------------------------------------------
-(void) loadPhysicalInformationFromDictionary:(NSDictionary*)dictionary{

    body = NULL;
    
    if(nil == dictionary)
        return;
    
    b2World* world = [[LHSettings sharedInstance] activeBox2dWorld];
    NSAssert(world!=nil, @"Box2d World must not be nil");
    
    b2BodyDef bodyDef;	
	
    int pType = [dictionary intForKey:@"Type"];//LH
    
	if(pType == 3) //"NO_PHYSIC"
        return;
    
	bodyDef.type = (b2BodyType)pType;
	
	CGPoint pos = self.position;	
	bodyDef.position.Set(pos.x/[[LHSettings sharedInstance] lhPtmRatio],
                         pos.y/[[LHSettings sharedInstance] lhPtmRatio]);
    
	bodyDef.angle = CC_DEGREES_TO_RADIANS(-1*self.rotation);
    
#ifndef LH_ARC_ENABLED
    bodyDef.userData = self;
#else
    bodyDef.userData = (__bridge void*)self;
#endif
    
    body = world->CreateBody(&bodyDef);    
	body->SetFixedRotation([dictionary boolForKey:@"FixedRot"]);
	        
    body->SetGravityScale([dictionary floatForKey:@"GravityScale"]);
	body->SetSleepingAllowed([dictionary boolForKey:@"CanSleep"]);    
    body->SetBullet([dictionary boolForKey:@"IsBullet"]);

    CGPoint linearVelocity = [dictionary pointForKey:@"LinearVelocity"];
    body->SetLinearVelocity(b2Vec2(linearVelocity.x, linearVelocity.y));
    
    body->SetAngularVelocity([dictionary floatForKey:@"AngularVelocity"]);
    body->SetLinearDamping([dictionary floatForKey:@"LinearDamping"]);
    body->SetAngularDamping([dictionary floatForKey:@"AngularDamping"]);
    
    
    NSArray* fixturesInfo = [dictionary objectForKey:@"SH_ComplexShapes"];
    
    fixturesObj = [[NSMutableArray alloc] init];
    
    for(NSDictionary* fixInfo in fixturesInfo)
    {
        LHFixture* lhFixture = [LHFixture fixtureWithDictionary:fixInfo body:body sprite:self];
        [fixturesObj addObject:lhFixture];
    }
}
-(void) loadAnimationsInformationFromDictionary:(NSDictionary*)dictionary{
    
    if(dictionary ==nil) return; //When sprite is loaded from SH dictionary this info is not available;
    
    //if sprite has no animation dictionary will be empty in order to make the level size smaller
    //so we test here to see if we should load anything
    if(![dictionary objectForKey:@"AnimName"]) return;
        
    
    [self prepareAnimationNamed:[dictionary stringForKey:@"AnimName"] 
                    fromSHScene:[dictionary stringForKey:@"SHScene"]];
    
    if(!animation) return;//something has gone wrong with animation loading
    
    if([dictionary boolForKey:@"AnimAtStart"])//we should pause the animation
        [animation play];
    
    [animation setLoop:[dictionary boolForKey:@"AnimLoop"]];
    [animation setRepetitions:[dictionary intForKey:@"AnimRepetitions"]];
    [animation setRestoreOriginalFrame:[dictionary boolForKey:@"AnimRestoreOriginalFrame"]];
    [animation setDelayPerUnit:[dictionary floatForKey:@"AnimSpeed"]];
}

-(void)loadPathMovementFromDictionary:(NSDictionary*)dictionary{
    if(!dictionary)return;
    
    //at this point we may not have a LHBezier in the level 
    //so we create the path after the level is fully loaded
    //but we save the path properties here
    if(![dictionary objectForKey:@"PathName"]) return;
       
    pathDefaultFlipX = [dictionary boolForKey:@"PathFlipX"];
    pathDefaultFlipY = [dictionary boolForKey:@"PathFlipX"];
    pathDefaultIsCyclic = [dictionary boolForKey:@"PathIsCyclic"];
    pathDefaultRelativeMove = [dictionary boolForKey:@"PathMoveDelta"];
    pathDefaultName = [[NSString alloc] initWithString:[dictionary stringForKey:@"PathName"]];
    pathDefaultOrientation = [dictionary intForKey:@"PathOrientation"];
    pathDefaultRestartOtherEnd = [dictionary boolForKey:@"PathOtherEnd"];
    pathDefaultSpeed = [dictionary floatForKey:@"PathSpeed"];
    pathStartAtLaunch= [dictionary boolForKey:@"PathStartAtLaunch"];
    pathDefaultStartPoint = [dictionary intForKey:@"PathStartPoint"];
}

-(void) loadInformationFromDictionary:(NSDictionary*)dictionary{
    
    if(nil != uniqueName)
        return; //compatibility with cocos2d 2.0
    
    if(nil != [dictionary objectForKey:@"UniqueName"]){
        uniqueName = [[NSMutableString alloc] initWithString:[dictionary stringForKey:@"UniqueName"]];
    }else {
        uniqueName = [[NSMutableString alloc] initWithFormat:@"UntitledSprite_%d", untitledSpritesCount];
        ++untitledSpritesCount;
    }
        
    if([dictionary objectForKey:@"SHSceneName"])
        shSceneName = [[NSString alloc] initWithString:[dictionary stringForKey:@"SHSceneName"]];
    
    if([dictionary objectForKey:@"SHSheetName"])
        shSheetName = [[NSString alloc] initWithString:[dictionary stringForKey:@"SHSheetName"]];
    if([dictionary objectForKey:@"SHSpriteName"])
        shSpriteName= [[NSString alloc] initWithString:[dictionary stringForKey:@"SHSpriteName"]];
    
    NSDictionary* texDict = [dictionary objectForKey:@"TextureProperties"];
    
    CGRect rectInPixels = self.textureRect;
    
    [[LHSettings sharedInstance] transformedTextureRect:self.textureRect forImage:[self imageFile]];
    
    rectInPixels = CC_RECT_POINTS_TO_PIXELS(self.textureRect);    
    
    CGSize contentSize = [texDict sizeForKey:@"SpriteSize"];
        
    CCSpriteFrame* sprFrame = [CCSpriteFrame frameWithTexture:self.texture
                                                 rectInPixels:rectInPixels
                                                      rotated:[texDict boolForKey:@"IsRotated"] 
                                                       offset:[texDict pointForKey:@"TextureOffset"]
                                                 originalSize:contentSize];
    [self setDisplayFrame:sprFrame];

    CGPoint scaleVal = [texDict pointForKey:@"Scale"];
    
    CGPoint scale = [[LHSettings sharedInstance] transformedPoint:scaleVal forImage:[self imageFile]];    
    
    [self setScaleX:scale.x];
    [self setScaleY:scale.y];
    
    realScale = CGSizeMake(scaleVal.x*[[LHSettings sharedInstance] convertRatio].x,
                           scaleVal.y*[[LHSettings sharedInstance] convertRatio].y);
    
    CGPoint position = [[LHSettings sharedInstance] transformedPointToCocos2d:[texDict pointForKey:@"Position"]];
    [self setPosition:position];
    
    
    [self setRotation:[texDict intForKey:@"Angle"]];
    [self setColor:[texDict colorForKey:@"Color"]];
    [self setVisible:[texDict boolForKey:@"IsDrawable"]];
    [self setOpacity:[texDict floatForKey:@"Opacity"]*255.0f];
    [self setTag:[texDict intForKey:@"Tag"]];
    zOrder_ = [texDict intForKey:@"ZOrder"];
    
    NSDictionary* phyDict = [dictionary objectForKey:@"PhysicProperties"];
    if([phyDict boolForKey:@"HandledBySH"] && ![dictionary objectForKey:@"IsSHSprite"])
    {        
        NSDictionary* sprDict = [[SHDocumentLoader sharedInstance] dictionaryForSpriteNamed:shSpriteName
                                                                               inSheetNamed:shSheetName
                                                                                 inDocument:shSceneName];
        phyDict = [sprDict objectForKey:@"PhysicProperties"];
    }
    
     //we do this because we need the batch to contain the sprite before loading any animation
    if([self batchNode]){
        [[self batchNode] addChild:self z:zOrder_];
    }

    originalRect = self.textureRect;

    [self loadPhysicalInformationFromDictionary:phyDict];
    
    [self loadAnimationsInformationFromDictionary:[dictionary objectForKey:@"AnimationsProperties"]];
    
//    customUserValues = [[NSMutableDictionary alloc] init];
    
    [self loadUserCustomInfoFromDictionary:[dictionary objectForKey:@"CustomClassInfo"]];
    
    [self loadPathMovementFromDictionary:[dictionary objectForKey:@"PathProperties"]];
    
    pathNode = nil;
    spriteIsInParallax = nil;
    
    touchBeginObserver = nil;
    touchMovedObserver = nil;
    touchEndedObserver = nil;
    
    tagTouchBeginObserver = nil;
    tagTouchMovedObserver = nil;
    tagTouchEndedObserver = nil;
    
    usesOverloadedTransformations = false;
    usePhysicsForTouches = true;
        
    [self scheduleUpdate];
}
-(void)setShSceneName:(NSString *)sceneName
{
    if(shSceneName)
        [shSceneName release];
    
    shSceneName = [[NSString alloc] initWithString:sceneName];
}
-(void)setParentLoader:(LevelHelperLoader*)p{
    parentLoader = p;
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(id)initBatchSpriteWithDictionary:(NSDictionary*)dictionary batch:(LHBatch*)batch{
        
    NSDictionary* texDict = [dictionary objectForKey:@"TextureProperties"];
    CGRect rect = CGRectFromString([texDict objectForKey:@"Frame"]);    
    
    rect = [[LHSettings sharedInstance] transformedTextureRect:rect forImage:[batch imagePath]];
        
#if COCOS2D_VERSION >= 0x00020000
    self = [super initWithTexture:[batch texture] rect:rect];
#else
    self = [super initWithBatchNode:batch rect:rect];
#endif
    
    if (self != nil){        
        [self setImageFile:[batch imagePath]];        
        [self loadInformationFromDictionary:dictionary];
    }
    return self;
}
//------------------------------------------------------------------------------
+(id)batchSpriteWithDictionary:(NSDictionary*)dictionary batch:(LHBatch*)batch{
#ifndef LH_ARC_ENABLED
    return [[[LHSprite alloc] initBatchSpriteWithDictionary:dictionary batch:batch] autorelease];
#else
    return [[LHSprite alloc] initBatchSpriteWithDictionary:dictionary batch:batch];
#endif     
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(id)initWithDictionary:(NSDictionary*)dictionary{
    
    NSString* imgPath = [[LHSettings sharedInstance] imagePath:[dictionary objectForKey:@"SheetImage"]];
    NSAssert(imgPath!=nil, @"Image path must not be nil");
    
    NSDictionary* texDict = [dictionary objectForKey:@"TextureProperties"];
    CGRect rect = CGRectFromString([texDict objectForKey:@"Frame"]);
    
    rect = [[LHSettings sharedInstance] transformedTextureRect:rect forImage:imgPath];
    
    self = [super initWithFile:imgPath rect:rect];    
    if (self != nil){
        [self setImageFile:imgPath];
        [self loadInformationFromDictionary:dictionary];
    }
    return self;
}
//------------------------------------------------------------------------------
+(id)spriteWithDictionary:(NSDictionary*)dictionary{
#ifndef LH_ARC_ENABLED
    return [[[LHSprite alloc] initWithDictionary:dictionary] autorelease];
#else
    return [[LHSprite alloc] initWithDictionary:dictionary];
#endif 
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
+(id)spriteWithName:(NSString*)spriteName 
          fromSheet:(NSString*)sheetName 
             SHFile:(NSString*)spriteHelperFile{

    NSDictionary* dictionary = [[SHDocumentLoader sharedInstance] dictionaryForSpriteNamed:spriteName 
                                                                              inSheetNamed:sheetName 
                                                                                inDocument:spriteHelperFile];
#ifndef LH_ARC_ENABLED
    LHSprite* sprite = [[[LHSprite alloc] initWithDictionary:dictionary] autorelease];
#else
    LHSprite* sprite = [[LHSprite alloc] initWithDictionary:dictionary];
#endif 
    
    if(sprite){      
        [sprite setShSceneName:spriteHelperFile];
    }
    return sprite;
}
//------------------------------------------------------------------------------
+(id)batchSpriteWithName:(NSString*)spriteName 
                   batch:(LHBatch*)batch{
    
    NSAssert(spriteName!=nil, @"Sprite name  must not be nil");
    NSAssert(batch!=nil, @"Batch must not be nil");
        
    NSDictionary* dictionary = [[SHDocumentLoader sharedInstance] dictionaryForSpriteNamed:spriteName 
                                                                              inSheetNamed:[batch uniqueName]
                                                                                inDocument:[batch shFile]];
#ifndef LH_ARC_ENABLED
    LHSprite* sprite = [[[LHSprite alloc] initBatchSpriteWithDictionary:dictionary batch:batch] autorelease];
#else
    LHSprite* sprite = [[LHSprite alloc] initBatchSpriteWithDictionary:dictionary batch:batch];
#endif     
    
    if(sprite){
        [batch addChild:sprite z:[sprite zOrder]];
        [sprite setShSceneName:[batch shFile]];
    }
    return sprite;
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(void)removeSelf{
    if(body){
        if(body->GetWorld()->IsLocked()){
            [[LHSettings sharedInstance] markSpriteForRemoval:self];
            return;
        }
    }
    [self removeFromParentAndCleanup:YES];
}
////////////////////////////////////////////////////////////////////////////////
-(void) setUniqueName:(NSString*)name{
    NSAssert(name!=nil, @"UniqueName must not be nil");
    [uniqueName setString:name];
}
//------------------------------------------------------------------------------
-(NSString*)uniqueName{
    return uniqueName;   
}
//------------------------------------------------------------------------------
-(void) setBody:(b2Body*)bd{
    NSAssert(bd!=nil, @"b2Body must not be nil");
    body = bd;
}
//------------------------------------------------------------------------------
-(b2Body*)body{
    return body;
}
//------------------------------------------------------------------------------
-(bool) removeBodyFromWorld{
    if(NULL != body){
		b2World* _world = body->GetWorld();
		if(0 != _world){
                       
            NSMutableArray* list = (NSMutableArray*)[self jointList];
            for(LHJoint* jt in list){
                [jt setShouldDestroyJointOnDealloc:NO];
                [jt removeSelf];
            }
            [list removeAllObjects];
            
			_world->DestroyBody(body);
			body = NULL;
            
            return true;
		}
	}
    return false;
}
////////////////////////////////////////////////////////////////////////////////
-(NSString*)imageFile{
    return imageFile;
}
-(void)setImageFile:(NSString*)img{
    
#ifndef LH_ARC_ENABLED
    if(imageFile)
        [imageFile release];
#endif
    
    imageFile = [[NSString alloc] initWithString:img];
}
//------------------------------------------------------------------------------
-(CGRect)originalRect{
    return originalRect;
}
-(void)setOriginalRect:(CGRect)rect{
    originalRect = rect;
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(void) transformPosition:(CGPoint)pos{
    [super setPosition:pos];
    if(0 != body){
        b2Vec2 boxPosition = [LevelHelperLoader pointsToMeters:pos];
        float angle = CC_DEGREES_TO_RADIANS(-1*super.rotation);
        body->SetTransform(boxPosition, angle);
    }
}
//------------------------------------------------------------------------------
-(CGPoint)position{
    return super.position;
}
//------------------------------------------------------------------------------
-(void)transformRotation:(float)rot{
    
    [super setRotation:rot];
    if(0 != body){
        b2Vec2 boxPosition = [LevelHelperLoader pointsToMeters:super.position];
        float angle = CC_DEGREES_TO_RADIANS(-1*rot);
        body->SetTransform(boxPosition, angle);
    }
}
//------------------------------------------------------------------------------
-(float)rotation{
    return super.rotation;
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(void)update:(ccTime)dt{    
    if(animation)
        [animation update:dt];
    
    if(pathNode)
        [pathNode update:dt];
}
//------------------------------------------------------------------------------
-(void) prepareAnimationNamed:(NSString*)animName fromSHScene:(NSString *)shScene{

    NSDictionary* animDict = [[SHDocumentLoader sharedInstance] dictionaryForAnimationNamed:animName
                                                                                 inDocument:shScene];
    if(animation){
        [animation release];
        animation = nil;
    }
    
    if(!animDict) {
        NSLog(@"ERROR: SpriteHelper document %@ for animation %@ needs to be updated. Animation is canceled.", shScene, animName);
        return;
    }
        
    NSString* textureFile = [animDict stringForKey:@"SheetImage"];
    NSString* animSheet = [animDict stringForKey:@"SheetName"];

    animation = [[LHAnimationNode alloc] initWithDictionary:animDict 
                                                   onSprite:self];

    if(![shSheetName isEqualToString:animSheet]){
        if(nil != textureFile){
            NSString* filePath = [CCFileUtils fullPathFromRelativePath:textureFile];
    
            if(filePath){
                CCTexture2D* newTexture = [[CCTextureCache sharedTextureCache] addImage:filePath];
                
                if(newTexture){
                    //if sprite is render by a batch node we need to remove if from the batch and 
                    //move it on the layer that contains the batch
                    LHBatch* parentBatch = (LHBatch*)[self batchNode];
                        
                    if(parentBatch){                       
                        [self removeFromParentAndCleanup:NO];
                        
                        [animation setOldBatch:parentBatch];
                        //we need to keep the z order so its batch z + sprite z 
                        if([parentBatch parent]){                            
                            [[parentBatch parent] addChild:self z:[parentBatch zOrder] + [self zOrder]];
                        }
                        else {
                            NSLog(@"ERROR: Sprite is render by batch node, but batch node has no parent.");
                        }
                    }   
                    else {
                        [animation setOldTexture:self.texture];
                    }
                    
                    [self setTexture:newTexture];
                    [shSheetName release];
                    shSheetName = [[NSString alloc] initWithString:animSheet];
                }
            }
        }
        else{
            [animation release];
            NSLog(@"ERROR: Image file %@ could not be found. Please add it in the resource folder.", textureFile);
        }
    }

    if(animation){
        [animation setOldRect:originalRect];
        [animation prepare];
    
    }
}
//------------------------------------------------------------------------------
-(void) playAnimation{ if(animation)[animation play];}
//------------------------------------------------------------------------------
-(void) pauseAnimation{ if(animation)[animation setPaused:YES];}
//------------------------------------------------------------------------------
-(void) restartAnimation{ if(animation)[animation setPaused:YES];}
//------------------------------------------------------------------------------
-(bool) animationIsPaused{ if(!animation)return false;
    return [animation paused];
}
//------------------------------------------------------------------------------
-(void) stopAnimation{

    if(!animation)return;

    [animation restoreFrame];

    [animation release];
    animation = nil;
}
//------------------------------------------------------------------------------
-(NSString*) animationName{ if(animation) return [animation uniqueName];
    return @"";
}
//------------------------------------------------------------------------------
-(int) numberOfFrames{ if(animation)return [animation numberOfFrames];    
    return -1;
}
//------------------------------------------------------------------------------
-(void) setFrame:(int)frmNo{ if(animation)[animation setFrame:frmNo];}
//------------------------------------------------------------------------------
-(int) currentFrame{ if(animation)[animation currentFrame];    
    return -1;
}
//------------------------------------------------------------------------------
-(void) nextFrame{ if(animation)[animation nextFrame];}
//------------------------------------------------------------------------------
-(void) prevFrame{ if(animation)[animation prevFrame];}
//------------------------------------------------------------------------------
-(void) nextFrameAndRepeat{ if(animation)[animation nextFrameAndRepeat];}
//------------------------------------------------------------------------------
-(void) prevFrameAndRepeat{ if(animation)[animation prevFrameAndRepeat];}
//------------------------------------------------------------------------------
-(bool) isAtLastFrame{ if(animation)return [animation isAtLastFrame];
    return false;
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(NSString*)userInfoClassName{
    if(userCustomInfo)
        return NSStringFromClass([userCustomInfo class]);
    return @"No Class";
}
//------------------------------------------------------------------------------
-(id)userInfo{
    return userCustomInfo;
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(NSArray*) jointList{
    NSMutableArray* array = [NSMutableArray array];
    if(body != NULL){
        b2JointEdge* jtList = body->GetJointList();
        while (jtList) {
            LHJoint* lhJt = [LHJoint jointFromBox2dJoint:jtList->joint];
            if(lhJt != NULL)
                [array addObject:lhJt];
            jtList = jtList->next;
        }
    }
    return array;
}
//------------------------------------------------------------------------------
-(LHJoint*) jointWithUniqueName:(NSString*)name{
    if(name == nil) return nil;
    NSArray* jointList = [self jointList];
    for(LHJoint* jt in jointList){
        if([[jt uniqueName] isEqualToString:name]){
            return jt;
        }
    }
    return nil;
}
//------------------------------------------------------------------------------
-(bool) removeAllAttachedJoints{
    NSArray* list = [self jointList];
    if(list){
        for(LHJoint* jt in list){
            [jt removeSelf];
        }
        return true;
    }
    return false;
}
//------------------------------------------------------------------------------
-(bool) removeJoint:(LHJoint*)joint{
    NSMutableArray* list = (NSMutableArray*)[self jointList];
    if(list){
        for(LHJoint* jt in list){
            if(jt == joint){
                [jt removeSelf];
                return true;
            }
        }
    }    
    NSLog(@"WARNING: Trying to remove joint %@ from the sprite %@ but the joint does not belong to that sprite. Removal of joint was not performed.", [joint uniqueName], uniqueName);
    return false;
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(void) prepareMovementOnPathWithUniqueName:(NSString*)pathName{
     NSAssert(pathName!=nil, @"UniqueName must not be nil");

    NSArray* allLayers = [[LHSettings sharedInstance] allLHMainLayers];

    LHBezier* bezier = nil;
    for(LHLayer* layer in allLayers){
        bezier = [layer bezierWithUniqueName:pathName];
        if(bezier)
            break;
    }
    if(bezier){
        pathNode = [[LHPathNode alloc] initPathNodeWithPoints:[bezier pathPoints] 
                                                     onSprite:self];
        [pathNode setPaused:YES];
        
        if(pathDefaultName)
            [pathDefaultName release];
        
        pathDefaultName = [[NSString alloc] initWithString:pathName];
        [pathNode setFlipX:pathDefaultFlipX];
        [pathNode setFlipY:pathDefaultFlipY];
        [pathNode setIsCyclic:pathDefaultIsCyclic];
        [pathNode setRelativeMovement:pathDefaultRelativeMove];
        [pathNode setAxisOrientation:pathDefaultOrientation];
        [pathNode setRestartOtherEnd:pathDefaultRestartOtherEnd];
        [pathNode setSpeed:pathDefaultSpeed];
        [pathNode setStartAtEndPoint:pathDefaultStartPoint];
    }
}

-(NSString*) pathUniqueName{
    return pathDefaultName;
}

-(void) startPathMovement{
    if(pathNode)[pathNode setPaused:NO];
}
-(void) pausePathMovement{
    if(pathNode)[pathNode setPaused:YES];
}
-(void) restartPathMovement{
    if(pathNode)[pathNode restart];
}
-(void) stopPathMovement{
    if(pathNode){[pathNode release]; pathNode = nil;}
}
-(void) setPathMovementSpeed:(float)value{
    if(pathNode)[pathNode setSpeed:value];
}
-(float)pathMovementSpeed{
    if(pathNode)return [pathNode speed];
    return 0.0f;
}
-(void) setPathMovementStartPoint:(enum LH_PATH_MOVEMENT_START_POINT)point{
    if(!pathNode)return;
    [pathNode setStartAtEndPoint:(bool)point];
}
-(enum LH_PATH_MOVEMENT_START_POINT) pathMovementStartPoint{
    if(!pathNode)return  LH_PATH_INVALID_POINT;
    return (enum LH_PATH_MOVEMENT_START_POINT)[pathNode startAtEndPoint];
}
-(void) setPathMovementIsCyclic:(bool)cyclic{
    
}
-(bool) pathMovementIsCyclic{
    if(!pathNode)return false;
    return [pathNode isCyclic];
}
-(void) setPathMovementRestartsAtOtherEnd:(bool)otherEnd{
    if(pathNode)[pathNode setRestartOtherEnd:otherEnd];
}
-(bool) pathMovementRestartsAtOtherEnd{
    if(!pathNode)return false;
    return [pathNode restartOtherEnd];
}
-(void) setPathMovementOrientation:(enum LH_PATH_MOVEMENT_ORIENTATION)point{
    if(pathNode)[pathNode setAxisOrientation:(int)point];
}
-(enum LH_PATH_MOVEMENT_ORIENTATION) pathMovementOrientation{
    if(!pathNode)return LH_INVALID_ORIENTATION;
    return (enum LH_PATH_MOVEMENT_ORIENTATION)[pathNode axisOrientation];
}
-(void) setPathMovementFlipXAtEnd:(bool)flip{
    if(pathNode)[pathNode setFlipX:flip];
}
-(bool) pathMovementFlipXAtEnd{
    if(!pathNode)return false;
    return [pathNode flipX];
}
-(void) setPathMovementFlipYAtEnd:(bool)flip{
    if(pathNode)[pathNode setFlipY:flip];    
}
-(bool) pathMovementFlipYAtEnd{
    if(!pathNode)return false;
    return [pathNode flipY];
}
-(void) setPathMovementRelative:(bool)rel{
    if(pathNode)[pathNode setRelativeMovement:rel];
}
-(bool) pathMovementRelative{
    if(!pathNode)return false;
    return [pathNode relativeMovement];
}
//-(void) moveOnPathWithUniqueName:(NSString*)pathName 
//                           speed:(float)pathSpeed 
//                 startAtEndPoint:(bool)startAtEndPoint
//                        isCyclic:(bool)isCyclic
//               restartAtOtherEnd:(bool)restartOtherEnd
//                 axisOrientation:(int)axis
//                           flipX:(bool)flipx
//                           flipY:(bool)flipy
//                   deltaMovement:(bool)dMove
//                  endObserverObj:(id)obj 
//                  endObserverSel:(SEL)sel
//{
//    
//    if(pathName == nil)
//        return;
//
//	//already moving on a path so lets cancel that path movement
//    [self cancelPathMovement];
//    
//	LHBezierNode* node = [parentLoader bezierNodeWithUniqueName:pathName];
//	
//	if(nil != node)
//	{
//		LHPathNode* pNode = [node addSpriteOnPath:self
//                                            speed:pathSpeed
//                                  startAtEndPoint:startAtEndPoint
//                                         isCyclic:isCyclic 
//                                restartAtOtherEnd:restartOtherEnd
//                                  axisOrientation:axis
//                                            flipX:flipx
//                                            flipY:flipy
//                                    deltaMovement:dMove];
//        
//        if(nil != pNode){
//            [pNode setPathNotifierObject:obj];
//            [pNode setPathNotifierSelector:sel];
//        }
//        pathNode = pNode;
//        
//#ifndef LH_ARC_ENABLED
//        [pathNode retain];
//#endif
//	}
//}
////------------------------------------------------------------------------------
//-(void) cancelPathMovement{
//    if(nil != pathNode){
//        [pathNode removeFromParentAndCleanup:YES];
//        pathNode = nil;
//    }
//}
////------------------------------------------------------------------------------
//-(void) pausePathMovement:(bool)pauseStatus
//{
//    if(nil != pathNode){
//        [pathNode setPaused:pauseStatus];
//    }
//}
////------------------------------------------------------------------------------
//-(void) setPathSpeed:(float)value{
//    if(pathNode != nil){
//        [pathNode setSpeed:value];
//    }
//}
////------------------------------------------------------------------------------
//-(float) pathSpeed{
//    if(pathNode != nil){
//        return [pathNode speed];
//    }
//    return 0;
//}
////------------------------------------------------------------------------------
//-(void) setPathNode:(LHPathNode*)node{
//    //NSAssert(node!=nil, @"LHPathNode must not be nil");    
//    pathNode = node;
//}
////------------------------------------------------------------------------------
//-(LHPathNode*)pathNode{
//    return pathNode;
//}
////////////////////////////////////////////////////////////////////////////////
-(bool)isTouchedAtPoint:(CGPoint)point{
    
    if(body == NULL || !usePhysicsForTouches)
    {
        float x = point.x;
        float y = point.y;

        float ax = quad_.tl.vertices.x/CC_CONTENT_SCALE_FACTOR();
        float ay = quad_.tl.vertices.y/CC_CONTENT_SCALE_FACTOR();
        
        float bx = quad_.tr.vertices.x/CC_CONTENT_SCALE_FACTOR();
        float by = quad_.tr.vertices.y/CC_CONTENT_SCALE_FACTOR();
        
        float dx = quad_.bl.vertices.x/CC_CONTENT_SCALE_FACTOR();
        float dy = quad_.bl.vertices.y/CC_CONTENT_SCALE_FACTOR();
                
#if COCOS2D_VERSION >= 0x00020000
        if(!self.batchNode)
#else
        if(!self.usesBatchNode)
#endif
        {
            ax += self.position.x;
            ay += self.position.y; 
            
            bx += self.position.x;
            by += self.position.y;
            
            dx += self.position.x;
            dy += self.position.y;
            
        }
        
        float bax=bx-ax;
        float bay=by-ay;
        float dax=dx-ax;
        float day=dy-ay;
        
        if ((x-ax)*bax+(y-ay)*bay<0.0) return false;
        if ((x-bx)*bax+(y-by)*bay>0.0) return false;
        if ((x-ax)*dax+(y-ay)*day<0.0) return false;
        if ((x-dx)*dax+(y-dy)*day>0.0) return false;
        
        return true;

    }
    else{
        b2Fixture* stFix = body->GetFixtureList();
        while(stFix != 0){
            if(stFix->TestPoint(b2Vec2(point.x/[[LHSettings sharedInstance] lhPtmRatio], 
                                       point.y/[[LHSettings sharedInstance] lhPtmRatio]))){
                return true;
            }
            stFix = stFix->GetNext();
        }
    }
    return false;    
}
-(void)setUsePhysicsForTouches:(bool)val{
    usePhysicsForTouches = val;
}
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
-(void)registerTouchBeginObserver:(id)observer selector:(SEL)selector{
    if(nil == touchBeginObserver)
        touchBeginObserver = [LHObserverPair observerPair];
    
    touchBeginObserver.object = observer;
    touchBeginObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [touchBeginObserver retain];
#endif
}
//------------------------------------------------------------------------------
-(void)registerTouchMovedObserver:(id)observer selector:(SEL)selector{
    if(nil == touchMovedObserver)
        touchMovedObserver = [LHObserverPair observerPair];
    
    touchMovedObserver.object = observer;
    touchMovedObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [touchMovedObserver retain];
#endif
}
//------------------------------------------------------------------------------
-(void)registerTouchEndedObserver:(id)observer selector:(SEL)selector{
    if(nil == touchEndedObserver)
        touchEndedObserver = [LHObserverPair observerPair];
    
    touchEndedObserver.object = observer;
    touchEndedObserver.selector = selector;    
#ifndef LH_ARC_ENABLED
    [touchEndedObserver retain];
#endif
}
//------------------------------------------------------------------------------
-(void)removeTouchObserver
{
#ifndef LH_ARC_ENABLED    
    [touchBeginObserver release];
    [touchMovedObserver release];
    [touchEndedObserver release];
#endif

    touchBeginObserver = nil;
    touchMovedObserver = nil;
    touchEndedObserver = nil;
    
    [LevelHelperLoader removeTouchDispatcherFromObject:self];
}
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
#ifdef __MAC_OS_X_VERSION_MAX_ALLOWED
//for left mouse events use the touch observers from above 
-(void)registerRightMouseDownObserver:(id)observer selector:(SEL)selector{
    if(nil == rightMouseDownObserver)
        rightMouseDownObserver = [LHObserverPair observerPair];
    
    rightMouseDownObserver.object = observer;
    rightMouseDownObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [rightMouseDownObserver retain];
#endif
}
//------------------------------------------------------------------------------
-(void)registerRightMouseDraggedObserver:(id)observer selector:(SEL)selector{
    if(nil == rightMouseDraggedObserver)
        rightMouseDraggedObserver = [LHObserverPair observerPair];
    
    rightMouseDraggedObserver.object = observer;
    rightMouseDraggedObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [rightMouseDraggedObserver retain];
#endif
}
//------------------------------------------------------------------------------
-(void)registerRightMouseUpObserver:(id)observer selector:(SEL)selector{
    if(nil == rightMouseUpObserver)
        rightMouseUpObserver = [LHObserverPair observerPair];
    
    rightMouseUpObserver.object = observer;
    rightMouseUpObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [rightMouseUpObserver retain];
#endif    
}
#endif

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
#ifdef __IPHONE_OS_VERSION_MAX_ALLOWED
-(CGPoint)convertedPoint:(CGPoint)touchPoint{
    touchPoint=  [[CCDirector sharedDirector] convertToGL:touchPoint];    
    
    CCNode* prevParent = nil;
    CCNode* layerParent = self.parent;
    
    while(layerParent){
        if(layerParent.parent){
            prevParent = layerParent;
            layerParent = layerParent.parent;
        }
        else{
            layerParent = prevParent;
            break;
        }
    }
    
    if(layerParent){
        touchPoint.x -= layerParent.position.x;
        touchPoint.y -= layerParent.position.y;
    }
    return touchPoint;
}
//------------------------------------------------------------------------------
- (BOOL)ccTouchBegan:(UITouch *)touch withEvent:(UIEvent *)event{
   
    if(self == nil)
        return NO;
    
    if(nil == touchBeginObserver && nil == tagTouchBeginObserver)
        return false;
    
    CGPoint touchPoint = [touch locationInView:[touch view]];
    touchPoint = [self convertedPoint:touchPoint];
        
    if([self isTouchedAtPoint:touchPoint])
    {
        LHTouchInfo* info = [LHTouchInfo touchInfo];
        info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                         touchPoint.y - self.position.y);
        info.glPoint = touchPoint;
        info.event = event;
        info.touch = touch;
        info.sprite = self;
        info.delta = CGPointZero;

        [LHObserverPair performObserverPair:touchBeginObserver object:info];
        [LHObserverPair performObserverPair:tagTouchBeginObserver object:info]; 
        return true;
    }
    return false;
}
//------------------------------------------------------------------------------
- (void)ccTouchMoved:(UITouch *)touch withEvent:(UIEvent *)event{  
    
    CGPoint touchPoint = [touch locationInView:[touch view]];
    touchPoint = [self convertedPoint:touchPoint];
        
    CGPoint prevLocation = [touch previousLocationInView:[touch view]];
    prevLocation = [self convertedPoint:prevLocation];

    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = touch;
    info.sprite = self;
    info.delta = CGPointMake(touchPoint.x - prevLocation.x,
                             touchPoint.y - prevLocation.y);

    [LHObserverPair performObserverPair:touchMovedObserver object:info];
    [LHObserverPair performObserverPair:tagTouchMovedObserver object:info]; 
}
//------------------------------------------------------------------------------
- (void)ccTouchEnded:(UITouch *)touch withEvent:(UIEvent *)event{

    CGPoint touchPoint = [touch locationInView:[touch view]];
    touchPoint= [self convertedPoint:touchPoint];

    CGPoint prevLocation = [touch previousLocationInView:[touch view]];
    prevLocation = [self convertedPoint:prevLocation];

    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = touch;
    info.sprite = self;
    info.delta = CGPointMake(touchPoint.x - prevLocation.x,
                             touchPoint.y - prevLocation.y);

    [LHObserverPair performObserverPair:touchEndedObserver object:info];
    [LHObserverPair performObserverPair:tagTouchEndedObserver object:info]; 
}

- (void)ccTouchCancelled:(UITouch *)touch withEvent:(UIEvent *)event{
}
//------------------------------------------------------------------------------
#elif defined(__MAC_OS_X_VERSION_MAX_ALLOWED)
//------------------------------------------------------------------------------
-(CGPoint)convertedEvent:(NSEvent*)event{
    CGPoint touchPoint = [(CCDirectorMac*)[CCDirector sharedDirector] convertEventToGL:event];
    
    CCNode* prevParent = nil;
    CCNode* layerParent = self.parent;
    
    while(layerParent){
        if(layerParent.parent){
            prevParent = layerParent;
            layerParent = layerParent.parent;
        }
        else{
            layerParent = prevParent;
            break;
        }
    }
    
    if(layerParent){
        touchPoint.x -= layerParent.position.x;
        touchPoint.y -= layerParent.position.y;
    }
    return touchPoint;
}
//------------------------------------------------------------------------------
-(BOOL) ccMouseDown:(NSEvent*)event{   
    
    CGPoint touchPoint = [self convertedEvent:event];
        
    if([self isTouchedAtPoint:touchPoint])
    {
        mouseDownStarted = true;
        LHTouchInfo* info = [LHTouchInfo touchInfo];
        info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                         touchPoint.y - self.position.y);
        info.glPoint = touchPoint;
        info.event = event;
        info.touch = nil;
        info.sprite = self;
        info.delta = CGPointZero;
        
        [LHObserverPair performObserverPair:touchBeginObserver object:info];
        [LHObserverPair performObserverPair:tagTouchBeginObserver object:info]; 

        return swallowTouches;
    }
    return NO;
}
//------------------------------------------------------------------------------
-(BOOL) ccMouseDragged:(NSEvent*)event{
    
    if(!mouseDownStarted)
        return NO;

    CGPoint touchPoint = [self convertedEvent:event];
            
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = nil;
    info.sprite = self;
    info.delta = CGPointMake([event deltaX], [event deltaY]);
    
    [LHObserverPair performObserverPair:touchMovedObserver object:info];
    [LHObserverPair performObserverPair:tagTouchMovedObserver object:info]; 

    return swallowTouches;//avoid propagation
}
//------------------------------------------------------------------------------
-(BOOL) ccMouseUp:(NSEvent*)event{
    
    if(!mouseDownStarted)
        return NO;

    CGPoint touchPoint = [self convertedEvent:event];
        
    mouseDownStarted = false;
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = nil;
    info.sprite = self;
    info.delta = CGPointMake([event deltaX], [event deltaY]);
    
    [LHObserverPair performObserverPair:touchEndedObserver object:info];
    [LHObserverPair performObserverPair:tagTouchEndedObserver object:info]; 

    return swallowTouches;//avoid propagation
}
//------------------------------------------------------------------------------
-(BOOL) ccRightMouseDown:(NSEvent*)event{
    
    CGPoint touchPoint = [self convertedEvent:event];
    
    if([self isTouchedAtPoint:touchPoint])
    {
        r_mouseDownStarted = true;
        LHTouchInfo* info = [LHTouchInfo touchInfo];
        info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                         touchPoint.y - self.position.y);
        info.glPoint = touchPoint;
        info.event = event;
        info.touch = nil;
        info.sprite = self;
        info.delta = CGPointZero;
        
        [LHObserverPair performObserverPair:rightMouseDownObserver object:info];
        [LHObserverPair performObserverPair:tagRightMouseDownObserver object:info]; 
        
        return swallowTouches;
    }
    return NO;
}
//------------------------------------------------------------------------------
-(BOOL) ccRightMouseDragged:(NSEvent*)event{
    
    if(!r_mouseDownStarted)
        return NO;

    CGPoint touchPoint = [self convertedEvent:event];
        
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = nil;
    info.sprite = self;
    info.delta = CGPointMake([event deltaX], [event deltaY]);
    
    [LHObserverPair performObserverPair:rightMouseDraggedObserver object:info];
    [LHObserverPair performObserverPair:tagRightMouseDraggedObserver object:info]; 
    
    return swallowTouches;//avoid propagation
}
//------------------------------------------------------------------------------
-(BOOL) ccRightMouseUp:(NSEvent*)event{
    
    if(!r_mouseDownStarted)
        return NO;

    CGPoint touchPoint = [self convertedEvent:event];
        
    r_mouseDownStarted = false;
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = nil;
    info.sprite = self;
    info.delta = CGPointMake([event deltaX], [event deltaY]);
    
    [LHObserverPair performObserverPair:rightMouseUpObserver object:info];
    [LHObserverPair performObserverPair:tagRightMouseUpObserver object:info]; 
    
    return swallowTouches;//avoid propagation
}

#endif

////////////////////////////////////////////////////////////////////////////////
+(NSString*) uniqueNameForBody:(b2Body*)body{
    
#ifndef LH_ARC_ENABLED
    id spr = (id)body->GetUserData();
#else
    id spr = (__bridge id)body->GetUserData();
#endif
    
    if([LHSprite isLHSprite:spr])
        return [spr uniqueName];
    
    if([LHBezier isLHBezier:spr])
        return [spr uniqueName];
    
    return nil;
}
//------------------------------------------------------------------------------
+(LHSprite*) spriteForBody:(b2Body*)body
{
    if(0 == body)
        return nil;
#ifndef LH_ARC_ENABLED 
    id spr = (id)body->GetUserData();
#else
    id spr = (__bridge id)body->GetUserData();
#endif
    
    if([LHSprite isLHSprite:spr])
        return spr;
    
    return nil;    
}
//------------------------------------------------------------------------------
+(int) tagForBody:(b2Body*)body{
    if(0 != body){
        #ifndef LH_ARC_ENABLED 
        CCNode* spr = (CCNode*)body->GetUserData();
        #else
        CCNode* spr = (__bridge CCNode*)body->GetUserData();
        #endif
        if(nil != spr){
            return [spr tag];
        }
    }
    return -1;
}
//------------------------------------------------------------------------------
+(bool) isLHSprite:(id)object{
    if([object isKindOfClass:[LHSprite class]]){
        return true;
    }
    return false;
}
////////////////////////////////////////////////////////////////////////////////
- (NSComparisonResult)sortAscending:(LHSprite *)other{

    if(nil == other)
        return NSOrderedSame;
    
    return [uniqueName compare:[other uniqueName]];
}
//------------------------------------------------------------------------------
- (NSComparisonResult)sortDescending:(LHSprite *)other
{		
    if(nil == other)
        return NSOrderedSame;

    NSComparisonResult result = [uniqueName compare:[other uniqueName]];
    
    if(result == NSOrderedDescending)
        return NSOrderedAscending;
    else if(result == NSOrderedAscending)
        return NSOrderedDescending;
    
    return NSOrderedSame;           
}
//------------------------------------------------------------------------------
-(void)setPosition:(CGPoint)pos
{
    if(usesOverloadedTransformations)
        [self transformPosition:pos];
    else {
        [super setPosition:pos];
    }
}
-(void)setRotation:(float)rot
{
    if(usesOverloadedTransformations)
        [self transformRotation:rot];
    else {
        [super setRotation:rot];
    }
}
//------------------------------------------------------------------------------
-(void)setCollisionFilterCategory:(int)category{
    if(body == nil)
        return;
    
    b2Fixture* curFix = body->GetFixtureList();
    while (curFix) {
        
        b2Filter curFilter = curFix->GetFilterData();

        b2Filter filter;
        filter.categoryBits = category;
        filter.maskBits     = curFilter.maskBits;
        filter.groupIndex   = curFilter.groupIndex;

        curFix->SetFilterData(filter);        
        curFix = curFix->GetNext();
    }
}
-(void)setCollisionFilterMask:(int)mask{
    if(body == nil)
        return;

    b2Fixture* curFix = body->GetFixtureList();
    while (curFix) {
        
        b2Filter curFilter = curFix->GetFilterData();
        
        b2Filter filter;
        filter.categoryBits = curFilter.categoryBits;
        filter.maskBits     = mask;
        filter.groupIndex   = curFilter.groupIndex;
        
        curFix->SetFilterData(filter);        
        curFix = curFix->GetNext();
    }
}
-(void)setCollisionFilterGroup:(int)group{
    if(body == nil)
        return;
    b2Fixture* curFix = body->GetFixtureList();
    while (curFix) {
        
        b2Filter curFilter = curFix->GetFilterData();
        
        b2Filter filter;
        filter.categoryBits = curFilter.categoryBits;
        filter.maskBits     = curFilter.maskBits;
        filter.groupIndex   = group;
        
        curFix->SetFilterData(filter);        
        curFix = curFix->GetNext();
    }
}

//TYPE CONVERSION
//------------------------------------------------------------------------------
-(void)makeDynamic{
    
    if(body == nil)
        return;
    
    body->SetType(b2_dynamicBody);    
}
-(void)makeStatic{
    if(body == nil)
        return;
    
    body->SetType(b2_staticBody);
}
-(void)makeKinematic{
    if(body == nil)
        return;

    body->SetType(b2_kinematicBody);
}
//------------------------------------------------------------------------------
@end
