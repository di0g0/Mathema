//  This file was generated by LevelHelper
//  http://www.levelhelper.org
//
//  LevelHelperLoader.mm
//  Created by Bogdan Vladu
//  Copyright 2011 Bogdan Vladu. All rights reserved.
////////////////////////////////////////////////////////////////////////////////
//
//  This software is provided 'as-is', without any express or implied
//  warranty.  In no event will the authors be held liable for any damages
//  arising from the use of this software.
//  Permission is granted to anyone to use this software for any purpose,
//  including commercial applications, and to alter it and redistribute it
//  freely, subject to the following restrictions:
//  The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software
//  in a product, an acknowledgment in the product documentation would be
//  appreciated but is not required.
//  Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
//  This notice may not be removed or altered from any source distribution.
//  By "software" the author refers to this code file and not the application 
//  that was used to generate this file.
//
////////////////////////////////////////////////////////////////////////////////
#import "LHBezier.h"
#import "LevelHelperLoader.h"
#import "LHTouchMgr.h"
#import "LHPathNode.h"
#import "LHSettings.h"
#import "LHSprite.h"
#import <Availability.h>

#import "LHDictionaryExt.h"

#ifdef __IPHONE_OS_VERSION_MAX_ALLOWED
#import <OpenGLES/EAGL.h>
#elif defined(__MAC_OS_X_VERSION_MAX_ALLOWED)
#import <OpenGL/OpenGL.h>
#endif


typedef struct _ccV3F_C4B_T2F_Triangle
{
	//! top left
	ccV3F_C4B_T2F	tl;
    //! top right
	ccV3F_C4B_T2F	tr;
	//! bottom
	ccV3F_C4B_T2F	bc;
    
} lhV3F_C4B_T2F_Triangle;


typedef struct lhV3F_C4B
{
    ccVertex3F point;
    ccColor4B color;    
} lhV3F_C4B;



typedef struct lhV3F_Line
{
	lhV3F_C4B	A;
	lhV3F_C4B	B;   
} lhV3F_Line;


@interface LHBezierBlendingInfo : NSObject
{
    CCTexture2D* texture;
    GLenum blendSource;
    GLenum blendDestination;
    bool tile;
}

+(id) bezierBlendingInfoWithTexture:(CCTexture2D*)tex
                        blendSource:(GLenum)source
                   blendDestination:(GLenum)destination
                               tile:(bool)shouldTile;

-(id) initBezierBlendingInfoWithTexture:(CCTexture2D*)tex
                            blendSource:(GLenum)source
                       blendDestination:(GLenum)destination
                                   tile:(bool)shouldTile;

-(CCTexture2D*) texture;
-(GLenum) blendSource;
-(GLenum) blendDestination;
-(bool) tile;
@end
//------------------------------------------------------------------------------
@implementation LHBezierBlendingInfo
-(void) dealloc{
#ifndef LH_ARC_ENABLED
	[super dealloc];
#endif
}
+(id) bezierBlendingInfoWithTexture:(CCTexture2D*)tex
                        blendSource:(GLenum)source
                   blendDestination:(GLenum)destination
                               tile:(bool)shouldTile;
{
#ifndef LH_ARC_ENABLED
	return [[[self alloc] initBezierBlendingInfoWithTexture:tex
                                                blendSource:source
                                           blendDestination:destination
                                                       tile:shouldTile] autorelease];
#else
    return [[self alloc] initBezierBlendingInfoWithTexture:tex
                                                blendSource:source
                                           blendDestination:destination
                                                       tile:shouldTile];
#endif
}
-(id) initBezierBlendingInfoWithTexture:(CCTexture2D*)tex
                            blendSource:(GLenum)source
                       blendDestination:(GLenum)destination
                                   tile:(bool)shouldTile{
	if( (self=[super init])) {
        texture = tex;
        blendSource = source;
        blendDestination = destination;
        tile = shouldTile;
	}
	return self;
}

-(CCTexture2D*) texture{return texture;}
-(GLenum) blendSource{return blendSource;}
-(GLenum) blendDestination{return blendDestination;}
-(bool) tile{return tile;}

@end


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
@interface LHBezier (Private)

@end
////////////////////////////////////////////////////////////////////////////////
@implementation LHBezier
@synthesize isClosed;
@synthesize isTile;
@synthesize isVisible;
@synthesize isLine;
@synthesize swallowTouches;
////////////////////////////////////////////////////////////////////////////////
-(void) dealloc{		
    
    NSLog(@"LHBezier Dealloc");
    
	if(NULL != body){
		b2World* _world = body->GetWorld();
		if(0 != _world){
			_world->DestroyBody(body);
			body = NULL;
		}
	}
    
#ifndef LH_ARC_ENABLED    
    if(touchBeginObserver)
        [touchBeginObserver release];
    if(touchBeginObserver)
        [touchMovedObserver release];
    if(touchBeginObserver)
        [touchEndedObserver release];    

    if(texture)
        [texture release];
    [blendingTextures release];
	[uniqueName release];	
	[pathPoints release];
	[linesHolder release];
	[trianglesHolder release];

	[super dealloc];
#endif
}

-(void)removeSelf{
    if(body){
        if(body->GetWorld()->IsLocked()){            
            [[LHSettings sharedInstance] markBezierForRemoval:self];
            return;
        }
    }
    [self removeFromParentAndCleanup:YES];
}
////////////////////////////////////////////////////////////////////////////////
+(CGPoint) pointOnCurve:(CGPoint) p1 p2:(CGPoint)p2 p3:(CGPoint)p3 p4:(CGPoint)p4 t:(float)t
{
	float var1, var2, var3;
    CGPoint vPoint = {0.0f, 0.0f};
    
    var1 = 1 - t;
    var2 = var1 * var1 * var1;
    var3 = t * t * t;
    vPoint.x = var2*p1.x + 3*t*var1*var1*p2.x + 3*t*t*var1*p3.x + var3*p4.x;
    vPoint.y = var2*p1.y + 3*t*var1*var1*p2.y + 3*t*t*var1*p3.y + var3*p4.y;
    return(vPoint);				
}
////////////////////////////////////////////////////////////////////////////////
-(void) initTileVerticesFromDictionary:(NSDictionary*)dictionary tileVertices:(NSArray*)fixtures
{
	trianglesHolder = [[NSMutableArray alloc] init];

    float scale = 1;
    #ifdef __IPHONE_OS_VERSION_MAX_ALLOWED
        scale = [[CCDirector sharedDirector] contentScaleFactor];
    #endif

//    NSLog(@"INIT TILE %@", dictionary);
    
	CGPoint convert = [[LHSettings sharedInstance] convertRatio];

	for(NSArray* fix in fixtures)
	{
		NSMutableArray* triangle = [[NSMutableArray alloc] init];
		for(NSString* pt in fix)
		{
			CGPoint point = CGPointFromString(pt);
			
            CGPoint pos_offset = [[LHSettings sharedInstance] possitionOffset];
            
			point.x = point.x* convert.x;
			point.y = winSize.height - point.y*convert.y;
            
            point.x += pos_offset.x;
            point.y -= pos_offset.y;
            
			[triangle addObject:LHValueWithCGPoint(point)];
		}
		
		[trianglesHolder addObject:triangle];
#ifndef LH_ARC_ENABLED
		[triangle release];
#endif
	}	
	
	
	linesHolder = [[NSMutableArray alloc] init];
	if(isVisible)
	{
		NSArray* curvesInShape = [dictionary objectForKey:@"Curves"];
		
		int MAX_STEPS = 25;
		
		for(NSDictionary* curvDict in curvesInShape)
		{
			CGPoint endCtrlPt   = [curvDict pointForKey:@"EndControlPoint"];
			CGPoint startCtrlPt = [curvDict pointForKey:@"StartControlPoint"];
			CGPoint endPt       = [curvDict pointForKey:@"EndPoint"];
			CGPoint startPt     = [curvDict pointForKey:@"StartPoint"];
			
            CGPoint pos_offset = [[LHSettings sharedInstance] possitionOffset];
                        
			if(!isLine)
			{
				CGPoint prevPoint;
				bool firstPt = true;
				
				for(float t = 0; t <= (1 + (1.0f / MAX_STEPS)); t += 1.0f / MAX_STEPS)
				{
					CGPoint vPoint = [LHBezier pointOnCurve:startPt
															 p2:startCtrlPt
															 p3:endCtrlPt
															 p4:endPt
															  t:t];
					
					if(!firstPt)
					{
						CGPoint pt1 = CGPointMake(prevPoint.x*convert.x, 
												  winSize.height - prevPoint.y*convert.y);
						CGPoint pt2 = CGPointMake(vPoint.x*convert.x, 
												  winSize.height - vPoint.y*convert.y);
						
                        pt1.x *= scale;
                        pt1.y *= scale;

                        pt2.x *= scale;
                        pt2.y *= scale;
                        
                        pt1.x += pos_offset.x;
                        pt1.y -= pos_offset.y;
                        
                        pt2.x += pos_offset.x;
                        pt2.y -= pos_offset.y;
                        
						[linesHolder addObject:LHValueWithCGPoint(pt1)];
						[linesHolder addObject:LHValueWithCGPoint(pt2)];
					}
					prevPoint = vPoint;
					firstPt = false;					
				}
			}
			else
			{
				
				CGPoint pos1 = CGPointMake(startPt.x*convert.x, 
										   winSize.height - startPt.y*convert.y);
				CGPoint pos2 = CGPointMake(endPt.x*convert.x, 
										   winSize.height - endPt.y*convert.y);
				
                pos1.x *= scale;
                pos1.y *= scale;
                
                pos2.x *= scale;
                pos2.y *= scale;
                
                pos1.x += pos_offset.x;
                pos1.y -= pos_offset.y;
                
                pos2.x += pos_offset.x;
                pos2.y -= pos_offset.y;

				[linesHolder addObject:LHValueWithCGPoint(pos1)];
				[linesHolder addObject:LHValueWithCGPoint(pos2)];
				
			}
		}
	}
}
////////////////////////////////////////////////////////////////////////////////
-(void) initPathPointsFromDictionary:(NSDictionary*)bezierDict
{
	pathPoints = [[NSMutableArray alloc] init];
	
    NSArray* curvesInShape = [bezierDict objectForKey:@"Curves"];    
    int MAX_STEPS = 25;    
	CGPoint conv = [[LHSettings sharedInstance] convertRatio];
	int i = 0;
    for(NSDictionary* curvDict in curvesInShape)
    {
        CGPoint endCtrlPt   = [curvDict pointForKey:@"EndControlPoint"];
        CGPoint startCtrlPt = [curvDict pointForKey:@"StartControlPoint"];
        CGPoint endPt       = [curvDict pointForKey:@"EndPoint"];
        CGPoint startPt     = [curvDict pointForKey:@"StartPoint"];
		
		CGPoint pos_offset = [[LHSettings sharedInstance] possitionOffset];
        
		if(!isLine)
        {
            for(float t = 0; t <= (1 + (1.0f / MAX_STEPS)); t += 1.0f / MAX_STEPS)
            {
                CGPoint vPoint = [LHBezier pointOnCurve:startPt
														 p2:startCtrlPt
														 p3:endCtrlPt
														 p4:endPt
														  t:t];
				vPoint = CGPointMake(vPoint.x*conv.x, 
                                     winSize.height - vPoint.y*conv.y);

                vPoint.x += pos_offset.x;
                vPoint.y -= pos_offset.y;
                
                [pathPoints addObject:LHValueWithCGPoint(vPoint)];
            }
			
			[pathPoints removeLastObject];
        }
        else
        {
            CGPoint sPoint = CGPointMake(startPt.x*conv.x, 
                                 winSize.height - startPt.y*conv.y);
            
            sPoint.x += pos_offset.x;
            sPoint.y -= pos_offset.y;
            
            [pathPoints addObject:LHValueWithCGPoint(sPoint)];            
            
            if(i == (int)[curvesInShape count]-1)
            {
                CGPoint ePoint = CGPointMake(endPt.x*conv.x, 
                                             winSize.height - endPt.y*conv.y);
                
                ePoint.x += pos_offset.x;
                ePoint.y -= pos_offset.y;
                
                [pathPoints addObject:LHValueWithCGPoint(ePoint)]; 
            }
            ++i;            
        }
	}	
	
}
////////////////////////////////////////////////////////////////////////////////
-(void) createBodyFromDictionary:(NSDictionary*)dictionary physicWorld:(b2World*)world
{
        
//	if(isPath)
//		return;
//	
//	if([pathPoints count] < 2)
//		return;
	
	b2BodyDef bodyDef;	
	
	int bodyType = [dictionary intForKey:@"Type"];
	if(bodyType > 2)
        return;
              
	bodyDef.type = (b2BodyType)bodyType;
    
	bodyDef.position.Set(0.0f, 0.0f);
	bodyDef.angle = 0.0f;
	
#ifndef LH_ARC_ENABLED
	bodyDef.userData = self;
#else
    bodyDef.userData = (__bridge void*)self;
#endif
	
	body = world->CreateBody(&bodyDef);
	
	float ptm = [[LHSettings sharedInstance] lhPtmRatio];

    for(NSArray* fix in trianglesHolder)
    {
        int size = [fix count];
        b2Vec2 *verts = new b2Vec2[size];
        int i = 0;
        for(int j = (int)[fix count]-1; j >=0; --j)
        {
            NSValue* val = [fix objectAtIndex:j];
                        
            CGPoint pt = LHPointFromValue(val);
            
            verts[i].x = pt.x/ptm;
            verts[i].y = pt.y/ptm;            
            ++i;
        }

        b2PolygonShape shape;
        shape.Set(verts, size);		
        
        b2FixtureDef fixture;
        
        
        fixture.density = [dictionary floatForKey:@"Density"];
		fixture.friction = [dictionary floatForKey:@"Friction"];
		fixture.restitution = [dictionary floatForKey:@"Restitution"];
		
		fixture.filter.categoryBits = [dictionary intForKey:@"Category"];
		fixture.filter.maskBits = [dictionary intForKey:@"Mask"];
		fixture.filter.groupIndex = [dictionary intForKey:@"Group"];
		
		fixture.isSensor = [dictionary boolForKey:@"IsSensor"];
        
        fixture.shape = &shape;
        body->CreateFixture(&fixture);
        delete[] verts;
    }		
    
    if([pathPoints count] > 0)
    {
    
        b2Vec2 * verts = new b2Vec2 [(int)[pathPoints count]];

        int i = 0;
        for(NSValue* val in pathPoints)
        {
            CGPoint pt = LHPointFromValue(val);
            verts [i]. x = pt.x / ptm;
            verts [i]. y = pt.y / ptm;
            ++i;
        }
        b2ChainShape shape;
        shape.CreateChain (verts, (int)[pathPoints count]);
    
        b2FixtureDef fixture;
    
    
        fixture.density = [dictionary floatForKey:@"Density"];
        fixture.friction = [dictionary floatForKey:@"Friction"];
        fixture.restitution = [dictionary floatForKey:@"Restitution"];
    
        fixture.filter.categoryBits = [dictionary intForKey:@"Category"];
        fixture.filter.maskBits = [dictionary intForKey:@"Mask"];
        fixture.filter.groupIndex = [dictionary intForKey:@"Group"];
    
        fixture.isSensor = [dictionary boolForKey:@"IsSensor"];

        fixture.shape = &shape;
        body-> CreateFixture (& fixture);
        delete [] verts;
    }   
}
////////////////////////////////////////////////////////////////////////////////
-(id) initWithDictionary:(NSDictionary*)dictionary 
{
	self = [super init];
	if (self != nil)
	{
     
        //NSLog(@"BEZIER DICT %@", dictionary);
        
        #if COCOS2D_VERSION >= 0x00020000
        self.shaderProgram = [[CCShaderCache sharedShaderCache] programForKey:kCCShader_PositionTextureColor];
        mShaderProgram = [[CCShaderCache sharedShaderCache] programForKey:kCCShader_Position_uColor];
        mColorLocation = glGetUniformLocation( mShaderProgram->program_, "u_color");
        #endif

        uniqueName = [[NSString alloc] initWithString:[dictionary stringForKey:@"UniqueName"]];		
        blendingTextures = [[NSMutableArray alloc] init];

        NSDictionary* textureDict = [dictionary objectForKey:@"TextureProperties"];

        
		isClosed	= [textureDict boolForKey:@"IsClosed"];
		isTile		= [textureDict boolForKey:@"IsTile"];
		isVisible	= [textureDict boolForKey:@"IsDrawable"];
		isLine		= [textureDict boolForKey:@"IsSimpleLine"];
		isPath		= [textureDict boolForKey:@"IsPath"];
		
        
		[self setTag:[textureDict intForKey:@"Tag"]];
		[self setVertexZ:[textureDict intForKey:@"ZOrder"]];
		
		NSString* img = [textureDict stringForKey:@"ImageFile"];
                
		imageSize = CGSizeZero;
		if(![img isEqualToString:@""])
		{
			NSString* path = [CCFileUtils fullPathFromRelativePath:img];
			texture = [[CCTextureCache sharedTextureCache] addImage:path];
           
            #ifndef LH_ARC_ENABLED
                [texture retain];
            #endif
            
            
			if( texture ) {
				imageSize = texture.contentSize;
			}
		}
		
		//CGPoint convert = [[LHSettings sharedInstance] convertRatio];
		winSize = [[CCDirector sharedDirector] winSize];		
		
		
		color       = [textureDict rectForKey:@"Color"];
		lineColor   = [textureDict rectForKey:@"LineColor"];
		lineWidth   = [textureDict floatForKey:@"LineWidth"];
    
        NSDictionary* physicsDict = [dictionary objectForKey:@"PhysicsProperties"];
		[self initTileVerticesFromDictionary:textureDict tileVertices:[physicsDict objectForKey:@"TileVertices"]];
		[self initPathPointsFromDictionary:textureDict];	
		
        b2World* world = [[LHSettings sharedInstance] activeBox2dWorld];
        NSAssert(world!=nil, @"Box2d World must not be nil");


		[self createBodyFromDictionary:physicsDict physicWorld:world];
        
        
        touchBeginObserver = nil;
        touchMovedObserver = nil;
        touchEndedObserver = nil;
        
        tagTouchBeginObserver = nil;
        tagTouchMovedObserver = nil;
        tagTouchEndedObserver = nil;
	}
	return self;
}
////////////////////////////////////////////////////////////////////////////////
+(id) bezierWithDictionary:(NSDictionary*)properties
{
#ifndef LH_ARC_ENABLED
	return [[[self alloc] initWithDictionary:properties] autorelease];
#else
    return [[self alloc] initWithDictionary:properties];
#endif
}
-(void)setParentLoader:(LevelHelperLoader*)p{
    parentLoader = p;
}
////////////////////////////////////////////////////////////////////////////////
-(NSString*)uniqueName{
    return uniqueName;
}
////////////////////////////////////////////////////////////////////////////////
-(b2Body*)body{
    return body;
}
////////////////////////////////////////////////////////////////////////////////
-(void)visit
{
	[super visit];
}
////////////////////////////////////////////////////////////////////////////////
#if COCOS2D_VERSION >= 0x00020000
-(void)draw{ //COCOS2D 2.0 draw call with GLES 2.0
        
    [super draw];
//    if(0.0f != [[LHSettings sharedInstance] customAlpha])
//	{
//		glPushMatrix();
		
        CC_NODE_DRAW_SETUP();
                		
        float scale = 1;
#ifdef __IPHONE_OS_VERSION_MAX_ALLOWED
        scale = [[CCDirector sharedDirector] contentScaleFactor];
#endif
        
        int size = [trianglesHolder count];
        
        lhV3F_C4B_T2F_Triangle points[size];// = new ccV3F_C4B_T2F_Triangle[size];
        
        ccColor4B colorVert = {color.origin.x*255.0f, color.origin.y*255.0f, color.size.width*255.0f, color.size.height*255.0f};
        
        for(int k = 0; k < (int)[trianglesHolder count]; ++k)
        {
            NSArray* fix = [trianglesHolder objectAtIndex:k];
            
            for(int j = 0; j < 3; ++j)
			{
                NSValue* val  = [fix objectAtIndex:j];
                
				CGPoint pt = LHPointFromValue(val);
                
                pt.x *=scale;
                pt.y *=scale;
                
                ccVertex3F vert = {pt.x, pt.y, 0};
                ccTex2F tex = {(pt.x/imageSize.width), ((winSize.height - pt.y)/imageSize.height)};
        
                if(j == 0)
                {
                    points[k].tl.vertices = vert;
                    points[k].tl.colors = colorVert;
                    points[k].tl.texCoords = tex;                
                }
                else if(j == 1)
                {
                    points[k].tr.vertices = vert;
                    points[k].tr.colors = colorVert;
                    points[k].tr.texCoords = tex;                                    
                }
                else if (j == 2)
                {
                    points[k].bc.vertices = vert;
                    points[k].bc.colors = colorVert;
                    points[k].bc.texCoords = tex;                
                }
			}
        }
        
        
        ccBlendFunc	blendFunc_;				// Needed for the texture protocol
    
        blendFunc_.src = GL_SRC_ALPHA;
        blendFunc_.dst = GL_ONE_MINUS_SRC_ALPHA;
    
        
        ccGLEnableVertexAttribs( kCCVertexAttribFlag_PosColorTex );
                
        ccGLBlendFunc( blendFunc_.src, blendFunc_.dst );
        
        ccGLBindTexture2D( texture.name );
        
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);

        
        #define kPointSize sizeof(ccV3F_C4B_T2F)
        long offset = (long)&points;
        
        // vertex
        NSInteger diff = offsetof( ccV3F_C4B_T2F, vertices);
        glVertexAttribPointer(kCCVertexAttrib_Position, 3, GL_FLOAT, GL_FALSE, kPointSize, (void*) (offset + diff));
        
        // texCoods
        diff = offsetof( ccV3F_C4B_T2F, texCoords);
        glVertexAttribPointer(kCCVertexAttrib_TexCoords, 2, GL_FLOAT, GL_FALSE, kPointSize, (void*)(offset + diff));
        
        // color
        diff = offsetof( ccV3F_C4B_T2F, colors);
        glVertexAttribPointer(kCCVertexAttrib_Color, 4, GL_UNSIGNED_BYTE, GL_TRUE, kPointSize, (void*)(offset + diff));
                 
        glDrawArrays(GL_TRIANGLES, 0, 3*size);
        
        
        bool wasBlend = glIsEnabled(GL_BLEND);
        glEnable(GL_BLEND);            
        
        for(LHBezierBlendingInfo* info in blendingTextures)
        {
            CCTexture2D* tex = [info texture];
            if(NULL != tex)
            {
                glBlendFunc([info blendSource], [info blendDestination]);
                glBindTexture(GL_TEXTURE_2D, [tex name]);
                
                if([info tile]){
                    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
                    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
                }
                
                glDrawArrays(GL_TRIANGLES, 0, 3*size);
            }
        }
        
        if(!wasBlend)
            glDisable(GL_BLEND);
        
        
        float oldLineWidth = 1.0f;
		glGetFloatv(GL_LINE_WIDTH, &oldLineWidth); 
		
		glLineWidth(lineWidth);
		
		
        ccColor4B colorLineVert = {lineColor.origin.x*255.0f, 
                                    lineColor.origin.y*255.0f, 
                                    lineColor.size.width*255.0f, 
                                    lineColor.size.height*255.0f};
    
    
        int linesNo = [linesHolder count];

    [mShaderProgram use];
	[mShaderProgram setUniformForModelViewProjectionMatrix];
    
	[mShaderProgram setUniformLocation:mColorLocation withF1:colorLineVert.r f2:colorLineVert.g f3:colorLineVert.b f4:colorLineVert.a];
    
    
    CGPoint* line_verts = new CGPoint[[linesHolder count]];
    for(int i = 0; i < (int)[linesHolder count]; i+=2)
    {
        CGPoint pt1 = LHPointFromValue([linesHolder objectAtIndex:i]);
        CGPoint pt2 = LHPointFromValue([linesHolder objectAtIndex:i+1]);
        
        line_verts[i] = pt1;
        line_verts[i+1] = pt2;            
    }  
    glVertexAttribPointer(kCCVertexAttrib_Position, 2, GL_FLOAT, GL_FALSE, 0, line_verts);
    
	glDrawArrays(GL_LINES, 0, linesNo);
	
	CC_INCREMENT_GL_DRAWS(1);
    
    delete[] line_verts;
    	
	CHECK_GL_ERROR_DEBUG();

}
#else

-(void)draw
{
	if(0.0f != [[LHSettings sharedInstance] customAlpha])
	{
		glColor4f(color.origin.x, 
				  color.origin.y, 
				  color.size.width, 
				  color.size.height*[[LHSettings sharedInstance] customAlpha]);
		glPushMatrix();
		
        glDisableClientState(GL_COLOR_ARRAY);
        
		glEnable(GL_TEXTURE_2D);		
		glBindTexture(GL_TEXTURE_2D, texture.name);
		
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
		
        float scale = 1.0f;
        #ifdef __IPHONE_OS_VERSION_MAX_ALLOWED
            scale = [[CCDirector sharedDirector] contentScaleFactor];
        #endif

        int size = [trianglesHolder count];
        CGPoint* glVertices = new CGPoint[size*3];
        CGPoint* glUV = new CGPoint[size*3];
        for(int k = 0; k < (int)[trianglesHolder count]; ++k)
        {
            NSArray* fix = [trianglesHolder objectAtIndex:k];
        
            for(int j = 0; j < 3; ++j)
			{
                NSValue* val  = [fix objectAtIndex:j];
                                
				CGPoint pt = LHPointFromValue(val);
                
                pt.x *=scale;
                pt.y *=scale;
				glVertices[k*3 +j] =pt;
				
				glUV[k*3+j].x = (pt.x/imageSize.width);
				glUV[k*3+j].y = ((winSize.height - pt.y)/imageSize.height);
			}
        }
        glTexCoordPointer(2, GL_FLOAT, 0, glUV);
        glVertexPointer(2, GL_FLOAT, 0, glVertices);
        glDrawArrays(GL_TRIANGLES, 0, 3*size);
        
        
        bool wasBlend = glIsEnabled(GL_BLEND);
        glEnable(GL_BLEND);            
        int oldBlendDST = 0;
        glGetIntegerv(GL_BLEND_DST, &oldBlendDST);
        int oldBlendSRC = 0;
        glGetIntegerv(GL_BLEND_SRC, &oldBlendSRC);
        
        for(LHBezierBlendingInfo* info in blendingTextures)
        {
            CCTexture2D* tex = [info texture];
            if(NULL != tex)
            {
                glBlendFunc([info blendSource], [info blendDestination]);
                glBindTexture(GL_TEXTURE_2D, [tex name]);
                
                if([info tile]){
                    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
                    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
                }
                
                glTexCoordPointer(2, GL_FLOAT, 0, glUV);
                glVertexPointer(2, GL_FLOAT, 0, glVertices);
                glDrawArrays(GL_TRIANGLES, 0, 3*size);                
            }
        }
        
        glBlendFunc(oldBlendSRC, oldBlendDST);
        if(!wasBlend)
            glDisable(GL_BLEND);
        
        
        delete[] glVertices;
        delete[] glUV;
        
        
        float oldLineWidth = 1.0f;
		glGetFloatv(GL_LINE_WIDTH, &oldLineWidth); 
		
		glLineWidth(lineWidth);
		
		glDisable(GL_TEXTURE_2D);
        glDisableClientState(GL_TEXTURE_COORD_ARRAY);
		glColor4f(lineColor.origin.x, 
				  lineColor.origin.y, 
				  lineColor.size.width, 
				  lineColor.size.height*[[LHSettings sharedInstance] customAlpha]);
		
        CGPoint* line_verts = new CGPoint[[linesHolder count]];
        for(int i = 0; i < (int)[linesHolder count]; i+=2)
		{
            CGPoint pt1 = LHPointFromValue([linesHolder objectAtIndex:i]);
			CGPoint pt2 = LHPointFromValue([linesHolder objectAtIndex:i+1]);
            
            line_verts[i] = pt1;
            line_verts[i+1] = pt2;            
		}
        glVertexPointer(2, GL_FLOAT, 0, line_verts);
        glDrawArrays(GL_LINES, 0, [linesHolder count]);
        delete[] line_verts;
        
        glEnableClientState(GL_TEXTURE_COORD_ARRAY);
        glEnableClientState(GL_COLOR_ARRAY);
		glLineWidth(oldLineWidth);
		glEnable(GL_TEXTURE_2D);	
		glPopMatrix();
	}	
}
#endif
////////////////////////////////////////////////////////////////////////////////
//-(LHPathNode*)addSpriteOnPath:(LHSprite*)spr
//                        speed:(float)pathSpeed 
//              startAtEndPoint:(bool)startAtEndPoint
//                     isCyclic:(bool)isCyclic
//            restartAtOtherEnd:(bool)restartOtherEnd
//              axisOrientation:(int)axis
//                        flipX:(bool)flipx
//                        flipY:(bool)flipy
//                deltaMovement:(bool)dMove;
//{
//	
//	LHPathNode* node = [LHPathNode nodePathWithPoints:pathPoints];	
//    [node setStartAtEndPoint:startAtEndPoint];
//	[node setSprite:spr];
//	[node setBody:[spr body]];
//    
//    if(!dMove){
//       if([pathPoints count] > 0){
//           CGPoint pathPos = LHPointFromValue([pathPoints objectAtIndex:0]);
//           [spr transformPosition:pathPos];
//       }
//    }
//    
//	[node setSpeed:pathSpeed];
//    [node setRestartOtherEnd:restartOtherEnd];
//	node.isCyclic = isCyclic;
//	node.axisOrientation = axis;
//	node.isLine = isLine;
//    node.flipX = flipx;
//    node.flipY = flipy;
//    [node setUniqueName:uniqueName];
//	//[pathNodes addObject:node];
//	
//	[self.parent addChild:node];
//    
//    return  node;
//}
////////////////////////////////////////////////////////////////////////////////
-(void) pushBlendingTextureNamed:(NSString*) texName
                      shouldTile:(bool)tile
                  blendingSource:(GLenum)blendSource
             blendingDestination:(GLenum)blendDestination{
    
    
    if(!isTile)
        return;
    
    CCTexture2D* tex = [[CCTextureCache sharedTextureCache] addImage:texName];
    if(NULL != tex){
        LHBezierBlendingInfo* info = [LHBezierBlendingInfo bezierBlendingInfoWithTexture:tex 
                                                                             blendSource:blendSource 
                                                                        blendDestination:blendDestination
                                                                                    tile:tile];
        [blendingTextures addObject:info];
    }
}
//------------------------------------------------------------------------------
-(void) pushBlendingTextureNamed:(NSString*) texName
                      shouldTile:(bool)tile{

    [self pushBlendingTextureNamed:texName
                        shouldTile:tile
                    blendingSource:GL_DST_COLOR
               blendingDestination:GL_ZERO];
}
//------------------------------------------------------------------------------
-(void) pushBlendingTextureNamed:(NSString*) texName{    
    [self pushBlendingTextureNamed:texName
                        shouldTile:YES
                    blendingSource:GL_DST_COLOR
               blendingDestination:GL_ZERO];
}
////////////////////////////////////////////////////////////////////////////////
+(bool) isLHBezier:(id)object{
    if([object isKindOfClass:[LHBezier class]]){
        return true;
    }
    return false;
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(bool)isTouchedAtPoint:(CGPoint)point{
    if(body != NULL)
    {
        b2Fixture* stFix = body->GetFixtureList();
        while(stFix != 0){
            if(stFix->TestPoint(b2Vec2(point.x/[[LHSettings sharedInstance] lhPtmRatio], 
                                       point.y/[[LHSettings sharedInstance] lhPtmRatio]))){
                return true;
            }
            stFix = stFix->GetNext();
        }
    }
    return false;    
}
//------------------------------------------------------------------------------
-(void)registerTouchBeginObserver:(id)observer selector:(SEL)selector{
    if(!isTile){
        CCLOG(@"Touch Events on bezier objects can only be performed on Tiled Shapes beziers. Touch Event Will be ignored.");
        return;
    }

    if(nil == touchBeginObserver)
        touchBeginObserver = [LHObserverPair observerPair];
    
    touchBeginObserver.object = observer;
    touchBeginObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [touchBeginObserver retain];
#endif
}
//------------------------------------------------------------------------------
-(void)registerTouchMovedObserver:(id)observer selector:(SEL)selector{
    if(!isTile){
        CCLOG(@"Touch Events on bezier objects can only be performed on Tiled Shapes beziers. Touch Event Will be ignored.");
        return;
    }

    if(nil == touchMovedObserver)
        touchMovedObserver = [LHObserverPair observerPair];
    
    touchMovedObserver.object = observer;
    touchMovedObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [touchMovedObserver retain];    
#endif
}
//------------------------------------------------------------------------------
-(void)registerTouchEndedObserver:(id)observer selector:(SEL)selector{

    if(!isTile){
        CCLOG(@"Touch Events on bezier objects can only be performed on Tiled Shapes beziers. Touch Event Will be ignored.");
        return;
    }
    
    if(nil == touchEndedObserver)
        touchEndedObserver = [LHObserverPair observerPair];
    
    touchEndedObserver.object = observer;
    touchEndedObserver.selector = selector; 
#ifndef LH_ARC_ENABLED
    [touchEndedObserver retain];
#endif
}
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
#ifdef __MAC_OS_X_VERSION_MAX_ALLOWED
//for left mouse events use the touch observers from above 
-(void)registerRightMouseDownObserver:(id)observer selector:(SEL)selector{
    if(nil == rightMouseDownObserver)
        rightMouseDownObserver = [LHObserverPair observerPair];
    
    rightMouseDownObserver.object = observer;
    rightMouseDownObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [rightMouseDownObserver retain];
#endif
}
//------------------------------------------------------------------------------
-(void)registerRightMouseDraggedObserver:(id)observer selector:(SEL)selector{
    if(nil == rightMouseDraggedObserver)
        rightMouseDraggedObserver = [LHObserverPair observerPair];
    
    rightMouseDraggedObserver.object = observer;
    rightMouseDraggedObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [rightMouseDraggedObserver retain];
#endif
}
//------------------------------------------------------------------------------
-(void)registerRightMouseUpObserver:(id)observer selector:(SEL)selector{
    if(nil == rightMouseUpObserver)
        rightMouseUpObserver = [LHObserverPair observerPair];
    
    rightMouseUpObserver.object = observer;
    rightMouseUpObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [rightMouseUpObserver retain];
#endif    
}
#endif
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
#ifdef __IPHONE_OS_VERSION_MAX_ALLOWED
- (BOOL)ccTouchBegan:(UITouch *)touch withEvent:(UIEvent *)event{
    CGPoint touchPoint = [touch locationInView:[touch view]];    
    touchPoint=  [[CCDirector sharedDirector] convertToGL:touchPoint];    

    
    if([self isTouchedAtPoint:touchPoint])
    {
        LHTouchInfo* info = [LHTouchInfo touchInfo];
        info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                         touchPoint.y - self.position.y);
        info.glPoint = touchPoint;
        info.event = event;
        info.touch = touch;
        info.bezier = self;
        info.delta = CGPointZero;

        [LHObserverPair performObserverPair:touchBeginObserver object:info];
        [LHObserverPair performObserverPair:tagTouchBeginObserver object:info]; 

        return swallowTouches;
    }
    return NO;
}
//------------------------------------------------------------------------------
- (void)ccTouchMoved:(UITouch *)touch withEvent:(UIEvent *)event{    
    CGPoint touchPoint = [touch locationInView:[touch view]];
    touchPoint=  [[CCDirector sharedDirector] convertToGL:touchPoint];
    
    CGPoint prevLocation = [touch previousLocationInView:[touch view]];
    prevLocation = [[CCDirector sharedDirector] convertToGL:prevLocation];    
    
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = touch;
    info.delta = CGPointMake(touchPoint.x - prevLocation.x,
                             touchPoint.y - prevLocation.y);
    info.bezier = self;
    
    [LHObserverPair performObserverPair:touchMovedObserver object:info];
    [LHObserverPair performObserverPair:tagTouchMovedObserver object:info];     
}
//------------------------------------------------------------------------------
- (void)ccTouchEnded:(UITouch *)touch withEvent:(UIEvent *)event{
    
    CGPoint touchPoint = [touch locationInView:[touch view]];
    touchPoint=  [[CCDirector sharedDirector] convertToGL:touchPoint];

    CGPoint prevLocation = [touch previousLocationInView:[touch view]];
    prevLocation = [[CCDirector sharedDirector] convertToGL:prevLocation];    

    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = touch;
    info.bezier = self;
    info.delta = CGPointMake(touchPoint.x - prevLocation.x,
                             touchPoint.y - prevLocation.y);

    [LHObserverPair performObserverPair:touchEndedObserver object:info];
    [LHObserverPair performObserverPair:tagTouchEndedObserver object:info];         
}
//------------------------------------------------------------------------------
#elif defined(__MAC_OS_X_VERSION_MAX_ALLOWED)
//------------------------------------------------------------------------------
-(BOOL) ccMouseDown:(NSEvent*)event{   
    
    CGPoint touchPoint = [(CCDirectorMac*)[CCDirector sharedDirector] convertEventToGL:event];
    
    if([self isTouchedAtPoint:touchPoint])
    {
        mouseDownStarted = true;
        LHTouchInfo* info = [LHTouchInfo touchInfo];
        info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                         touchPoint.y - self.position.y);
        info.glPoint = touchPoint;
        info.event = event;
        info.touch = nil;
        info.bezier = self;
        info.delta = CGPointZero;
        
        [LHObserverPair performObserverPair:touchBeginObserver object:info];
        [LHObserverPair performObserverPair:tagTouchBeginObserver object:info]; 
        
        return swallowTouches;
    }
    return NO;//propagation
}
//------------------------------------------------------------------------------
-(BOOL) ccMouseDragged:(NSEvent*)event{
    
    if(!mouseDownStarted)
        return NO;

    CGPoint touchPoint = [(CCDirectorMac*)[CCDirector sharedDirector] convertEventToGL:event];
            
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = nil;
    info.bezier = self;
    info.delta = CGPointMake([event deltaX], [event deltaY]);
    
    [LHObserverPair performObserverPair:touchMovedObserver object:info];
    [LHObserverPair performObserverPair:tagTouchMovedObserver object:info]; 
    
    return swallowTouches;//avoid propagation
}
//------------------------------------------------------------------------------
-(BOOL) ccMouseUp:(NSEvent*)event{
    
    if(!mouseDownStarted)
        return NO;

    CGPoint touchPoint = [(CCDirectorMac*)[CCDirector sharedDirector] convertEventToGL:event];
    
    mouseDownStarted = false;
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = nil;
    info.bezier = self;
    info.delta = CGPointMake([event deltaX], [event deltaY]);
    
    [LHObserverPair performObserverPair:touchEndedObserver object:info];
    [LHObserverPair performObserverPair:tagTouchEndedObserver object:info]; 
    
    return swallowTouches;//avoid propagation
}
//------------------------------------------------------------------------------
-(BOOL) ccRightMouseDown:(NSEvent*)event{
    
    CGPoint touchPoint = [(CCDirectorMac*)[CCDirector sharedDirector] convertEventToGL:event];
    
    if([self isTouchedAtPoint:touchPoint])
    {
        r_mouseDownStarted = true;
        LHTouchInfo* info = [LHTouchInfo touchInfo];
        info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                         touchPoint.y - self.position.y);
        info.glPoint = touchPoint;
        info.event = event;
        info.touch = nil;
        info.bezier = self;
        info.delta = CGPointZero;
        
        [LHObserverPair performObserverPair:rightMouseDownObserver object:info];
        [LHObserverPair performObserverPair:tagRightMouseDownObserver object:info]; 
        
        return swallowTouches;
    }
    return NO;//propagation
}
//------------------------------------------------------------------------------
-(BOOL) ccRightMouseDragged:(NSEvent*)event{
    
    if(!r_mouseDownStarted)
        return NO;

    CGPoint touchPoint = [(CCDirectorMac*)[CCDirector sharedDirector] convertEventToGL:event];
    
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = nil;
    info.bezier = self;
    info.delta = CGPointMake([event deltaX], [event deltaY]);
    
    [LHObserverPair performObserverPair:rightMouseDraggedObserver object:info];
    [LHObserverPair performObserverPair:tagRightMouseDraggedObserver object:info]; 
    
    return swallowTouches;//avoid propagation
}
//------------------------------------------------------------------------------
-(BOOL) ccRightMouseUp:(NSEvent*)event{
    
    if(!r_mouseDownStarted)
        return NO;
    
    CGPoint touchPoint = [(CCDirectorMac*)[CCDirector sharedDirector] convertEventToGL:event];
    r_mouseDownStarted = false;
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = nil;
    info.bezier = self;
    info.delta = CGPointMake([event deltaX], [event deltaY]);
    
    [LHObserverPair performObserverPair:rightMouseUpObserver object:info];
    [LHObserverPair performObserverPair:tagRightMouseUpObserver object:info]; 
    
    return swallowTouches;//avoid propagation
}
//------------------------------------------------------------------------------
#endif //touch events on mac
//------------------------------------------------------------------------------

@end
